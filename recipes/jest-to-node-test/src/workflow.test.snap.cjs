exports[`workflow > should migrate jest to node:test 1`] = `
"import { describe, it, mock } from \\"node:test\\";\\nimport { expect } from \\"expect\\";\\n\\ndescribe(\\"test\\", () => {\\n\\tit(\\"should be a test\\", (t) => {\\n\\t\\tconst a = mock.fn((i: number, j: number) => i + j);\\n\\t\\tconst b = mock.fn(async (i: number, j: number) => i - j);\\n\\t\\tmock.module(\\"./workflow.ts\\");\\n\\n\\t\\tconst logSpy = mock.method(console,\\"log\\");\\n\\t\\tconsole.log(\\"Hello, world!\\");\\n\\n\\t\\texpect(logSpy.mock.calls.map((call) => call.arguments)[0][0]).toBe(\\"Hello, world!\\");\\n\\n\\t\\ta(1, 1);\\n\\t\\ta(2, 2);\\n\\n\\t\\texpect(a.mock.callCount()).toBeTruthy();\\n\\t\\texpect(a.mock.callCount()).toBeTruthy();\\n\\n\\t\\texpect(a.mock.callCount()).toBe(2);\\n\\t\\texpect(a.mock.callCount()).toBe(2);\\n\\n\\t\\texpect(a.mock.calls.map(call => call.arguments)).toContainEqual([1,1]);\\n\\t\\texpect(a.mock.calls.map(call => call.arguments)).toContainEqual([1,1]);\\n\\n\\t\\texpect(a.mock.calls.at(-1)?.arguments).toStrictEqual([2,2]);\\n\\t\\texpect(a.mock.calls.at(-1)?.arguments).toStrictEqual([2,2]);\\n\\n\\t\\texpect(a.mock.calls[0].arguments).toStrictEqual([1,1]);\\n\\t\\texpect(a.mock.calls[1].arguments).toStrictEqual([2,2]);\\n\\n\\t\\texpect(a.mock.calls.some(call => call.error === undefined)).toBeTruthy();\\n\\t\\texpect(a.mock.calls.some(call => call.error === undefined)).toBeTruthy();\\n\\n\\t\\texpect(a.mock.calls.filter(call => call.error === undefined)).toHaveLength(2);\\n\\t\\texpect(a.mock.calls.filter(call => call.error === undefined)).toHaveLength(2);\\n\\n\\t\\texpect(a.mock.calls.map(call => call.result)).toContainEqual(2);\\n\\t\\texpect(a.mock.calls.map(call => call.result)).toContainEqual(4);\\n\\n\\t\\texpect(a.mock.calls.at(-1)?.result).toBe(4);\\n\\t\\texpect(a.mock.calls.at(-1)?.result).toBe(4);\\n\\n\\t\\texpect(a.mock.calls[0].result).toBe(2);\\n\\t\\texpect(a.mock.calls[1].result).toBe(4);\\n\\n\\t\\ta.mock.calls.map((call) => call.arguments);\\n\\n\\t\\ta.mock.calls.map((call) => ({\\n\\ttype: call.error ? \\"throw\\" : \\"return\\",\\n\\tvalue: call.error ? call.error : call.result,\\n}));\\n\\n\\t\\t// a.mock.instances;\\n\\n\\t\\t// a.mock.contexts;\\n\\n\\t\\ta.mock.calls.at(-1)?.arguments;\\n\\n\\t\\ta.mock.resetCalls();\\n\\n\\t\\ta.mock.restore();\\n\\n\\t\\ta.mock.restore();\\n\\n\\t\\ta.mock.mockImplementation((i: number, j: number) => i * j);\\n\\n\\t\\ta.mock.mockImplementationOnce((i: number, j: number) => i - j);\\n\\n\\t\\t// a.mockName(\\"myMock\\");\\n\\n\\t\\t// a.mockReturnThis();\\n\\n\\t\\ta.mock.mockImplementation(() => 42);\\n\\n\\t\\ta.mock.mockImplementationOnce(() => 42);\\n\\n\\t\\tb.mock.mockImplementation(async () => {\\n\\tthrow new Error(\\"Test error\\");\\n});\\n\\n\\t\\tb.mock.mockImplementationOnce(async () => {\\n\\tthrow new Error(\\"Test error once\\");\\n});\\n\\n\\t\\tb.mock.mockImplementation(async () => 42);\\n\\n\\t\\tb.mock.mockImplementationOnce(async () => 42);\\n\\n\\t\\tt.assert.snapshot({ a: 1 });\\n\\n\\t\\tt.assert.snapshot({ b: 2 });\\n\\n\\t\\tmock.timers.enable();\\n\\n\\t\\tmock.timers.reset();\\n\\n\\t\\tmock.timers.runAll();\\n\\n\\t\\tmock.timers.runAll();\\n\\n\\t\\tmock.timers.runAll();\\n\\n\\t\\tmock.timers.runAll();\\n\\n\\t\\tmock.timers.tick(1000);\\n\\n\\t\\tmock.timers.tick(1000);\\n\\n\\t\\tmock.timers.runAll();\\n\\n\\t\\tmock.timers.runAll();\\n\\n\\t\\t// jest.advanceTimersToNextTimer(5);\\n\\n\\t\\t// jest.advanceTimersToNextTimerAsync(5);\\n\\n\\t\\tmock.timers.reset();\\n\\n\\t\\tjest.getTimerCount();\\n\\n\\t\\tDate.now();\\n\\n\\t\\tmock.timers.setTime(Number(1000));\\n\\n\\t\\t// jest.getRealSystemTime();\\n\\t});\\n});\\n"
`;
